<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Model Viewer - Water Pump</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            color: #fff;
        }
        canvas {
            display: block;
        }
        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
        }
        /* New style for device info */
        #deviceInfo {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 8px 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            font-size: 16px;
            pointer-events: none; /* So it doesn't interfere with camera controls */
        }
    </style>
</head>
<body>
    <div id="loader">Loading Model...</div>
    <!-- New element for device info -->
    <div id="deviceInfo">Loading device info...</div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- New: Get device ID from URL ---
        const urlParams = new URLSearchParams(window.location.search);
        const deviceId = urlParams.get("device") || 0;

        let scene, camera, renderer, controls, clock, modelGroup;
        let isUserInteracting = false;
        let idleTimer;
        const idleTimeout = 3000; // 3 seconds of inactivity

        // --- New variables for shaking effect ---
        let vibrationData = { rms: 0 };
        let originalModelPosition = new THREE.Vector3();

        const resetPosition = new THREE.Vector3(-80, 60, 80); // Top-left view to snap back to
        let isReturningToHome = false;


        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333); // Dark gray background
            scene.fog = new THREE.Fog(0x333333, 150, 400);

            // Group to hold the model
            modelGroup = new THREE.Group();
            scene.add(modelGroup);

            // Clock for animations
            clock = new THREE.Clock();

            // Camera
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(resetPosition); // Start at the reset position

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 20;
            controls.maxDistance = 300;
            controls.target.set(0, 15, 0); // Target the center of the model
            controls.autoRotate = false; // Start with auto-rotate off
            controls.autoRotateSpeed = 0.5; // Adjust speed of rotation here
            
            controls.addEventListener('start', () => {
                isUserInteracting = true;
                isReturningToHome = false;
                controls.autoRotate = false; // Explicitly stop auto-rotate on interaction
                clearTimeout(idleTimer);
            });
            controls.addEventListener('end', () => {
                idleTimer = setTimeout(() => { 
                    isUserInteracting = false; 
                    isReturningToHome = true; // Begin the process of returning to the home position
                }, idleTimeout);
            });

            // Lighting
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 2.5);
            hemiLight.position.set(0, 100, 0);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 3);
            dirLight.position.set(50, 50, 50);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.top = 70;
            dirLight.shadow.camera.bottom = -70;
            dirLight.shadow.camera.left = -70;
            dirLight.shadow.camera.right = 70;
            scene.add(dirLight);

            // Ground plane
            const groundGeo = new THREE.PlaneGeometry(500, 500);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8, metalness: 0.2 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // GLTF Loader
            const loader = new GLTFLoader();
            loader.load('/static/models/water_pump_realistic/scene.gltf', function (gltf) {
                const model = gltf.scene;
                
                // --- Center and scale the model ---
                const box = new THREE.Box3().setFromObject(model);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());

                // Scale model to a reasonable size
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 50.0 / maxDim; // Scale so max dimension is 50 units
                model.scale.set(scale, scale, scale);

                // Center the model
                model.position.x += (model.position.x - center.x) * scale;
                model.position.y += (model.position.y - center.y) * scale;
                model.position.y += 11;
                model.position.z += (model.position.z - center.z) * scale;
                
                // Store the initial centered position
                originalModelPosition.copy(model.position);
                
                // Ensure all meshes in the model cast and receive shadows
                model.traverse(function (node) {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                    }
                });
                
                modelGroup.add(model);
                
                // Hide loader text and start fetching data
                document.getElementById('loader').style.display = 'none';
                setInterval(fetchVibrationData, 2000); // Fetch data every 2 seconds

            }, undefined, function (error) {
                console.error(error);
                document.getElementById('loader').innerText = 'Error loading model.';
            });
            
            // --- New: Fetch and display device info ---
            fetchDeviceInfo();

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }
        
        // --- New function to get device name ---
        async function fetchDeviceInfo() {
            try {
                const response = await fetch(`/devices`);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const devices = await response.json();
                const deviceInfoEl = document.getElementById('deviceInfo');
                
                if (devices && devices[deviceId] && devices[deviceId].name) {
                    const deviceName = devices[deviceId].name;
                    deviceInfoEl.textContent = `Device: ${deviceName}`;
                    document.title = `3D Viewer - ${deviceName}`;
                } else {
                    deviceInfoEl.textContent = `Device ID: ${deviceId}`;
                    document.title = `3D Viewer - Device ${deviceId}`;
                }
            } catch (error) {
                console.error("Could not fetch device info:", error);
                document.getElementById('deviceInfo').textContent = `Device ID: ${deviceId} (Info unavailable)`;
            }
        }

        // --- Fetch vibration data from backend ---
        async function fetchVibrationData() {
            try {
                // Use the deviceId constant defined at the top
                const response = await fetch(`/data?device=${deviceId}`);
                if (!response.ok) return;
                const data = await response.json();
                if (data && typeof data.rms !== 'undefined') {
                    vibrationData = data;
                }
            } catch (error) {
                console.error("Could not fetch vibration data:", error);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            // Apply shaking if the model is loaded
            if (modelGroup.children.length > 0 && vibrationData && vibrationData.rms > 0) {
                const shakeIntensity = vibrationData.rms * 0.1; // Adjust this multiplier for more/less shake
                
                const shakeX = (Math.random() - 0.5) * shakeIntensity;
                const shakeY = (Math.random() - 0.5) * shakeIntensity;
                const shakeZ = (Math.random() - 0.5) * shakeIntensity;
                
                // Apply shake relative to the original centered position
                modelGroup.position.copy(originalModelPosition).add(new THREE.Vector3(shakeX, shakeY, shakeZ));
            }

            if (!isUserInteracting) {
                if (isReturningToHome) {
                    controls.autoRotate = false;
                    camera.position.lerp(resetPosition, delta * 1.5);
                    if (camera.position.distanceTo(resetPosition) < 0.5) {
                        isReturningToHome = false;
                    }
                } else {
                    controls.autoRotate = true;
                }
            } else {
                controls.autoRotate = false;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>


